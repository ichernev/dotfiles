#!/usr/bin/env python3

import sys
import subprocess
import threading
import time
import datetime
import json
import traceback
import re
from pathlib import Path

read_thread = None
write_thread = None

def log(msg):
    print(f"{datetime.datetime.now().isoformat()}: {msg}", file=sys.stderr)

def power_state() -> str:
    online = Path('/sys/class/power_supply/ACAD/online').read_text().strip()
    cap = Path('/sys/class/power_supply/BAT1/capacity').read_text().strip()
    return f"{cap} {'AC' if online else 'BAT'}"

def mem_used() -> str:
    total = None
    free = None
    for line in Path('/proc/meminfo').read_text().split('\n'):
        if line.startswith('MemTotal:'):
            total = int(line.split()[1])
        elif line.startswith('MemFree:'):
            free = int(line.split()[1])

    perc = int((total - free) / total * 100) 
    return f'{perc}%'

def load_avg() -> str:
    pcs = Path('/proc/loadavg').read_text().split()
    return " ".join(pcs[:3])

def brightness() -> str:
    bl = Path('/sys/class/backlight/intel_backlight')
    bl_max = (bl / 'max_brightness').read_text().strip()
    bl_crnt = (bl / 'brightness').read_text().strip()

    perc = int(bl_crnt) * 100 // int(bl_max)
    return f'{perc}'

def volume() -> str:
    res = subprocess.run('pamixer --get-volume', shell=True, capture_output=True, text=True)
    return res.stdout.strip()


class ReadThread(threading.Thread):
    def __init__(self, ev):
        super().__init__()
        self.last_state: dict = {}
        self.last_id = 0
        self.ev = ev

    def run(self):
        # time.sleep(10000)
        for line in sys.stdin:
            self.last_state = json.loads(line)
            self.last_id += 1
            # print("STATE", self.last_state, file=sys.stderr)
            log(f"DBG A:{self.active} NE:{self.non_empty}")
            self.ev.set()
            self.ev.clear()

    @property
    def title(self) -> str | None:
        return self.last_state.get('title')

    @property
    def active(self) -> int:
        return int(self.last_state.get('tags', {}).get('BOE', ['1'])[0])

    @property
    def non_empty(self) -> list[int]:
        tags = self.last_state.get('viewstag', {}).get('BOE', [])
        return [int(t) for t in set(tags)]

def tag_show(x):
    if x < 10:
        return f'{x % 10}'
    return f'F{x-9}'

class WriteThread(threading.Thread):
    def __init__(self, ev):
        super().__init__()
        self.ev = ev

    def run(self):
        skip_wait = False
        while True:
            try:
                F_RESET = '%{F:0xAAAAAA}'
                if not skip_wait:
                    # wait for 1 sec or until set
                    self.ev.wait(1)
                skip_wait = False
                crnt_id = read_thread.last_id
                active = read_thread.active
                non_empty = read_thread.non_empty
                if active not in non_empty:
                    non_empty.append(active)
                non_empty.sort()

                left_pcs = []
                for ne in non_empty:
                    nes = tag_show(ne)
                    if ne == active:
                        left_pcs.append(f'%{{F:0xFFFF00}}[{nes}]{F_RESET}')
                    else:
                        left_pcs.append(nes)

                title = read_thread.title
                if title:
                    chars_left = 99 - len(re.subn('%{[^}]+}', '', " ".join(left_pcs))[0])
                    log(f"CL {chars_left}")
                    if len(title) > chars_left:
                        title = title[:chars_left - 1] + '\u2026'
                    left_pcs.append(':')
                    left_pcs.append(f'%{{F:0x00FF00}}{title}{F_RESET}')
                    
                pcs = []
                pcs.append(f'%{{r}}[{power_state()}')
                pcs.append('|')
                pcs.append(f'{mem_used()}')
                pcs.append('|')
                pcs.append(f'{load_avg()}]')
                pcs.append(f'%{{r}}%{{F:0xFFFF00}}{brightness()} {F_RESET}')
                pcs.append(f'%{{r}}%{{F:0x00FF00}}{volume()} {F_RESET}')

                date = datetime.datetime.now().strftime("%a %d %b %H:%M")
                pcs.append(f'%{{r}}%{{F:0xFF8000}}{date}{F_RESET}')

                left_part = " ".join(left_pcs) 
                right_part = " ".join(pcs)
                line = f'{left_part} {right_part}'
                log(f"LINE: {line}")
                if crnt_id != read_thread.last_id:
                    log("oops, redraw")
                    skip_wait = True
                    continue
                print(line, flush=True)
            except Exception as e:
                log("SOME SHIT")
                traceback.print_exception(e, file=sys.stderr)
                # print("got e", e, file=sys.stderr)

def main(args):
    global read_thread
    global write_thread

    ev = threading.Event()
    read_thread = ReadThread(ev)
    write_thread = WriteThread(ev)

    read_thread.start()
    write_thread.start()

    write_thread.join()
    read_thread.join()

if __name__ == '__main__':
    main(sys.argv[1:])
